<!DOCTYPE html>
<html>
<body>	

    <p>Space to jump and wall jump. Arrows to move. Shift to wall grab.</p>
	<canvas id="canvas" width="500" height="500" style="background-color: rgb(100, 100, 100); border: 3px solid black;">
		Your browser does not support the HTML5 canvas tag
	</canvas>

	<script src='engine/collision.js'></script>
	<script src='engine/dynamics.js'></script>
	<script src='engine/math.js'></script>
	<script>

		canvas.focus();
		var c = canvas.getContext("2d");
		var keys = new Object();

		document.onkeydown = function(e){
			keys[e.keyCode] = true;
		}

		document.onkeyup = function(e){
			delete keys[e.keyCode];
		}

		var KEY_ENTER = 13;
		var KEY_UP = 38;
		var KEY_DOWN = 40;
		var KEY_LEFT = 37;
		var KEY_RIGHT = 39;
		var KEY_SPACE = 32;
		var KEY_SHIFT = 16;

		var friction = 0.9999;
		var gravity = 0.001;

		var bodies;
		var oldTime;
		var player;
		function setup(){
			oldTime = performance.now();
			bodies = [];

			player = body(vec(canvas.width * 3/20, canvas.height * 3/20), vec(0, 0), 40, 80);
			player.mass = 8;
			player.color = hsl(0.3,1,0.9);
			bodies.push(player);

			var edgeUp = body(vec(0,0), vec(0,0), canvas.width, canvas.height / 20);
			var edgeDown = body(vec(0, canvas.height * 19/20), vec(0,0), canvas.width, canvas.height / 20);
			var edgeLeft = body(vec(0,0), vec(0,0), canvas.width / 20, canvas.height);
			var edgeRight = body(vec(canvas.width * 19/20 ,0), vec(0,0), canvas.width / 20, canvas.height);

			var edgeMid = body(vec(canvas.width / 2, canvas.height * 9/20), vec(0,0), canvas.width / 2, canvas.height / 20);

			for(var edge of [edgeUp,edgeDown,edgeLeft,edgeRight, edgeMid]){
				edge.isEdge = true;
				edge.mass = Infinity;
				edge.color = 'black';
				bodies.push(edge);
			}
		} setup();

		function update(time){
			var timeStep = Math.min(time - oldTime, 100);
			oldTime = time;

			if(keys[KEY_ENTER])
				setup();

			controls(timeStep);
			physics(timeStep);
		}

		var acceleration = 0.0020;
		var onGround = false;
		var onWall = false;
		var onCeiling = false;
		var alreadyJumped = false;
		var alreadyWallJumped = false;
		var airControl = 0.15;
		var stamina = 100;
		var staminaRegen = 0.05;
		var coolDown = 0;

		function controls(timeStep){
			onGround = isColliding(footBody());
			onWall = isColliding(sideBody());
			onCeiling = isColliding(headBody());

			if(!onGround)
				alreadyJumped = false;

			if(!onWall)
				alreadyWallJumped = false;

			var control = onGround ? 1 : (onCeiling ? 0.5 : airControl);

			if(onGround){
				stamina += staminaRegen * timeStep;
				if(stamina > 100)
					stamina = 100;
			}

			coolDown -= timeStep;
			if(coolDown < 0)
				coolDown = 0;

			if(keys[KEY_SPACE] && onWall && !alreadyWallJumped && spendStamina(20, 10)){
				var isLeft = isColliding(leftSideBody());
				player.velocity.x += isLeft ? 0.3 : -0.3;
				player.velocity.y += -0.4;
				alreadyWallJumped = true;
			}

			if(keys[KEY_SPACE] && onGround && !alreadyJumped && spendStamina(20, 10)){
				alreadyJumped = true;
				player.velocity.y += -0.5;
			}

			if(keys[KEY_LEFT])
				player.velocity.x -= acceleration * timeStep * control;

			if(keys[KEY_RIGHT])
				player.velocity.x += acceleration * timeStep * control;

			if(keys[KEY_SHIFT] && onWall && !alreadyWallJumped && spendStamina(0.5, 0)){
				player.velocity.x *= 0.5;
				player.velocity.y *= 0.5
			}

			if(keys[KEY_SHIFT] && onCeiling && spendStamina(1, 0)){
				player.velocity.y -= 1;
			}
		}

		function spendStamina(amount, coolDownTime){
			if(stamina >= amount && coolDown <= 0){
				coolDown = coolDownTime;
				stamina -= amount;
				return true;
			}
			return false;
		}

		function physics(timeStep){
			for(var body of bodies){
				if(!body.isEdge)
					body.velocity.y += gravity * timeStep;

				body.velocity.x *= Math.pow(friction, timeStep);
				body.velocity.y *= Math.pow(friction, timeStep);
			}

			runFor(timeStep, bodies, function(body, other, side){
				var restitution = body == player || other == player ? 0.1 : 0.5;
				bounce(body, other, side, restitution);
			})
		}

		var controlRegionSize = 5;
		function footBody(){
			var foot = body(vclone(player.position), vec(0,0), player.width, controlRegionSize * 2);
			foot.position.y += player.height - controlRegionSize;
			return foot;
		}

		var headRegionSize = 10;
		function headBody(){
			var head = body(vclone(player.position), vec(0,0), player.width, headRegionSize * 2);
			head.position.y -= headRegionSize;
			return head;
		}

		function sideBody(){
			var face = body(vclone(player.position), vec(0,0), player.width + controlRegionSize * 2, player.height);
			face.position.x -= controlRegionSize;
			return face;
		}

		function leftSideBody(){
			var face = body(vclone(player.position), vec(0,0), controlRegionSize + player.width / 2, player.height);
			face.position.x -= controlRegionSize;
			return face;
		}

		function isColliding(body){
			for(var other of bodies){
				if(other === player)
					continue;
				if(intersects(body, other))
					return true;
			}
			return false;
		}

		function draw(body, color){
			c.fillStyle = 'black';
			c.fillRect(body.position.x - 1, body.position.y - 1, body.width + 2, body.height + 2);
			c.fillStyle = color || body.color || 'red';
			c.fillRect(body.position.x, body.position.y, body.width, body.height);
		}

		var showControlRegions = false;
		function render(){
			c.clearRect(0, 0, canvas.width, canvas.height);
			if(player && showControlRegions){
				draw(footBody(), onGround ? 'green' : 'red');
				draw(sideBody(), onWall ? 'green' : 'red');
				draw(headBody(), onCeiling ? 'green' : 'red');
			}
			for(var block of bodies){
				draw(block);
			}

			c.fillStyle = 'rgb(0,70,0)';
			c.fillRect(0,0,100,20);
			c.fillStyle = 'green';
			c.fillRect(0,0,stamina,20);
		}

		function reload(time){
			update(time);
			render();
			requestAnimationFrame(reload);
		}	reload(performance.now());
		
	</script>
</body>
</html>
<!DOCTYPE html>
<html>
<body>
	<canvas id="canvas" width="500" height="500" style="background-color: rgb(750, 750, 750); border: 3px solid black;">
		Your browser does not support the HTML5 canvas tag
	</canvas>
	<script src='engine/collision.js'></script>
	<script src='engine/math.js'></script>
	<script>

		canvas.focus();
		var c = canvas.getContext("2d");
		var keys = new Object();

		document.onkeydown = function(e){
			keys[e.keyCode] = true;
		}

		document.onkeyup = function(e){
			delete keys[e.keyCode];
		}

		var KEY_ENTER = 13;
		var KEY_UP = 38;
		var KEY_DOWN = 40;
		var KEY_LEFT = 37;
		var KEY_RIGHT = 39;

		var acceleration = 0.001;
		var restitution = 0.5;
		var friction = 0.999;
		var surfaceFriction = 0.9;
		var gravity = 0.0005;
		function setup(){
			oldTime = performance.now();
			boxA = box(vec(10, 10), 10, 20);
			boxB = box(vec(100, 200), 300, 100);
			velocity = vec(0,0);
		} setup();

		function update(time){
			var timeStep = time - oldTime;
			oldTime = time;

			if(keys[KEY_ENTER])
				setup();

			controls(timeStep);
			physics(timeStep);
		}

		function controls(timeStep){
			if(keys[KEY_UP])
				velocity.y -= acceleration * timeStep;
			if(keys[KEY_DOWN])
				velocity.y += acceleration * timeStep;
			if(keys[KEY_LEFT])
				velocity.x -= acceleration * timeStep;
			if(keys[KEY_RIGHT])
				velocity.x += acceleration * timeStep;
		}

		function physics(timeStep){
			var impact = impactData(boxA, boxB, velocity);
			var remainingTime = timeStep;

			if(impact.time <= timeStep && impact.time >= 0){
				console.log(impact.side);

				move(impact.time);
				bounce(impact.side);
				remainingTime -= impact.time;
			}

			move(remainingTime);

			if(boxA.position.x < 0 || boxA.position.x > canvas.width - boxA.width){
				bounce('left');
				boxA.position.x = clamp(0, canvas.width - boxA.width, boxA.position.x);
			}
			if(boxA.position.y < 0 || boxA.position.y > canvas.height - boxA.height){
				bounce('up');
				boxA.position.y = clamp(0, canvas.height - boxA.height, boxA.position.y);
			}

			velocity.x *= Math.pow(friction, timeStep); //Friction
			velocity.y *= Math.pow(friction, timeStep);

			velocity.y += gravity * timeStep;
		}

		function move(timeStep){
			boxA.position.x += timeStep * velocity.x;
			boxA.position.y += timeStep * velocity.y;
		}

		function bounce(side){
			if(side == 'left' || side == 'right'){
				velocity.x *= -restitution;
				velocity.y *= surfaceFriction;
			}
			else{
				velocity.y *= -restitution;
				velocity.x *= surfaceFriction;
			}
		}

		function render(){
			c.clearRect(0, 0, canvas.width, canvas.height);
			var draw = function(aBox, color){
				c.fillStyle = color;
				c.fillRect(aBox.position.x, aBox.position.y, aBox.width, aBox.height)
			};
			draw(boxB, 'blue');
			draw(boxA, 'red');
		}

		function reload(time){
			update(time);
			render();
			requestAnimationFrame(reload);
		}	reload(performance.now());
		
	</script>
</body>
</html>